/* mdsc -- multiple dictionary spell checker Copyright (C) 2014-2015 The Open University Based on code from Jazzy - a Java library for Spell Checking Copyright (C) 2001-2005 Mindaugas Idzelis  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation with the 'classpath' exception,  either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. The full text of the licence can be found in the file LICENCE.txt*/package uk.ac.open.crc.mdsc.engine;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.util.HashMap;import java.util.List;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Yet another <code>SpellDictionary</code> this one is based on Damien * Guillaume's Diskbased dictionary but adds a cache to try to improve a bit on * performance. * * @author Robert Gustavsson * @version 0.01 */public class CachedDichotomyDiskSpellingDictionary extends         DichotomyDiskSpellingDictionary {    private static final Logger LOGGER =             LoggerFactory.getLogger( CachedDichotomyDiskSpellingDictionary.class );    // SB: review the wisdom of caching dictionaries externally, when they could     // be built and loaded in binary form in jars    // also be cautious about platform dependencies     public static final String MDSC_DIR = ".mdsc";    public static final String PRE_CACHE_FILE_EXTENSION = ".pre";    private static final int MAX_CACHED = 10_000;    private final HashMap<String,CacheObject> suggestionCache;    private String preCacheFileName;    private String preCacheDir;    /**     * Dictionary Convenience Constructor.     *     * @param wordList a file containing a list of words one per line.     * @throws java.io.FileNotFoundException if file is not accessible     */    public CachedDichotomyDiskSpellingDictionary( File wordList )            throws FileNotFoundException, IOException {        super( (File) wordList );        this.suggestionCache = new HashMap<>( MAX_CACHED );        loadPreCache( wordList );    }    /**     * Dictionary Convenience Constructor.     *     * @param wordList a file containing a list of words     * @param encoding the encoding for the file     * @throws java.io.FileNotFoundException if the file cannot be located     */    public CachedDichotomyDiskSpellingDictionary( File wordList, String encoding )            throws FileNotFoundException, IOException {        super( wordList, encoding );        this.suggestionCache = new HashMap<>( MAX_CACHED );        loadPreCache( wordList );    }    /**     * Dictionary constructor that uses an aspell phonetic file to build the     * transformation table.     *     * @param wordList a file containing a list of words.     * @param phonetic an aspell phonetic file     * @throws java.io.FileNotFoundException if either file cannot be located     */    public CachedDichotomyDiskSpellingDictionary( File wordList, File phonetic )            throws FileNotFoundException, IOException {        super( wordList, phonetic );        this.suggestionCache = new HashMap<>( MAX_CACHED );        loadPreCache( wordList );    }    /**     * Dictionary constructor that uses an aspell phonetic file to build the     * transformation table.     *     * @param wordList a file containing a list of words     * @param phonetic an aspell phonetic file     * @param encoding the character encoding used in the word list     * @throws java.io.FileNotFoundException if either file cannot be located     * @throws java.io.IOException generic file system or read errors.     */    public CachedDichotomyDiskSpellingDictionary( File wordList, File phonetic, String encoding )            throws FileNotFoundException, IOException {        super( wordList, phonetic, encoding );        this.suggestionCache = new HashMap<>( MAX_CACHED );        loadPreCache( wordList );    }    /**     * Add a word permanently to the dictionary (and the dictionary file).     * <i>not implemented !</i>     */    @Override    public void addWord( String word ) {        LOGGER.error( "Attempt to add word to CachedDichotomySpellingDictionary" );        throw new UnsupportedOperationException(                "error: addWord is not implemented for "                + "CachedDichotomyDiskSpellingDictionary" );    }    /**     * Clears the cache.     */    public void clearCache() {        this.suggestionCache.clear();    }    /**     * Returns a list of strings (words) for the code.     *     * @return a list of words.     */    @Override    public List<String> getWords( String code ) {        List<String> wordList;//        CachedDichotomyDiskSpellingDictionary.codes++;        if ( this.suggestionCache.containsKey( code ) ) {//            CachedDichotomyDiskSpellingDictionary.hits++;            wordList = getCachedList( code );            return wordList;        }        wordList = super.getWords( code );        addToCache( code, wordList );        return wordList;    }    /**     * This method returns the cached suggestion list and also moves the code to     * the top of the codeRefQueue to indicate this code has recently been     * referenced.     */    private List getCachedList( String code ) {        CacheObject cacheObject = this.suggestionCache.get( code );        cacheObject.setReferencedTime();        return cacheObject.getSuggestionList();    }    /**     * Adds a code and its suggestion list to the cache.     */    private void addToCache( String code, List<String> wordList ) {         String lowestCode = null;        long lowestTime = Long.MAX_VALUE;        if ( this.suggestionCache.size() >= MAX_CACHED ) {            for ( String c : suggestionCache.keySet() ) {                CacheObject cacheObject = this.suggestionCache.get( c );                if ( cacheObject.getRefeferencedTime() == 0 ) {                    lowestCode = c;                    break;                }                if ( lowestTime > cacheObject.getRefeferencedTime() ) {                    lowestCode = c;                    lowestTime = cacheObject.getRefeferencedTime();                }            }            this.suggestionCache.remove( lowestCode );        }        this.suggestionCache.put( code, new CacheObject( wordList ) );    }    // SB: loadPrecachedFile ??    /**     * Load the cache from file. The cache file has the same name as the dichotomy     * file with the .pre extension added.     */    private void loadPreCache( File dichotomyFile ) throws IOException {        String code;        List suggestions;        long size;        long time;        File preFile;                this.preCacheDir = System.getProperty( "user.home" ) + "/" + MDSC_DIR;        this.preCacheFileName = this.preCacheDir + "/"                 + dichotomyFile.getName()                 + PRE_CACHE_FILE_EXTENSION;        //System.out.println(preCacheFileName);        preFile = new File( this.preCacheFileName );        if ( !preFile.exists() ) {            System.err.println( "No precache file" );            return;        }        //System.out.println("Precaching...");        try (ObjectInputStream in =                 new ObjectInputStream( new FileInputStream( preFile ) ) ) {            size = in.readLong();            for ( int i = 0; i < size; i++ ) {                code = (String) in.readObject();                time = in.readLong();                suggestions = (List) in.readObject();                this.suggestionCache.put( code, new CacheObject( suggestions, time ) );            }        }        catch ( ClassNotFoundException ex ) {            // SB: Review this catch and the try above            System.out.println( ex.getMessage() );        }    }    /**     * @throws java.io.IOException Saves the current cache to file.     */    public void saveCache() throws IOException {        // SB: surely this is IllegalStateException territory        // SB: Need to log it         // Read the calling code to determine how error handling is performed.        if ( this.preCacheFileName == null || this.preCacheDir == null ) {            System.err.println( "Precache filename has not been set." );            return;        }        //System.out.println("Saving cache to precache file...");        File cacheDirectory = new File( this.preCacheDir );        if ( !cacheDirectory.exists() ) {            cacheDirectory.mkdir();        }        File cacheFile = new File( this.preCacheFileName );        try (ObjectOutputStream out =                 new ObjectOutputStream( new FileOutputStream( cacheFile ) ) ) {            out.writeLong( this.suggestionCache.size() );            for ( String code : this.suggestionCache.keySet() ) {                CacheObject cacheObject = this.suggestionCache.get( code );                out.writeObject( code );                out.writeLong( cacheObject.getRefeferencedTime() );                out.writeObject( cacheObject.getSuggestionList() );            }        }        catch ( IOException e ) {            // log            LOGGER.error(                     "Unable to save to cache: {}",                     e.getMessage());            // rethrow the exception            throw ( e );        }    }    // INNER CLASSES    // ------------------------------------------------------------------------    private class CacheObject implements Serializable {        private final List<String> suggestions;        private long referencedTime;        public CacheObject( List<String> list ) {            this.suggestions = list;            this.referencedTime = 0;        }        public CacheObject( List<String> list, long time ) {            this.suggestions = list;            this.referencedTime = time;        }        public List<String> getSuggestionList() {            return this.suggestions;        }        public void setReferencedTime() {            this.referencedTime = System.currentTimeMillis();        }        public long getRefeferencedTime() {            return this.referencedTime;        }    }}